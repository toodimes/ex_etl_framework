All Files for ExEtlFramework
# ex_etl_framework.ex
defmodule ExEtlFramework do
 
end

# applicatin.ex
defmodule ExEtlFramework.Application do
  use Application
  import Telemetry.Metrics

  @impl true
  def start(_type, _args) do
    children = [
      {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    opts = [strategy: :one_for_one, name: ExEtlFramework.Supervisor]
    Supervisor.start_link(children, opts)
  end

  defp metrics do
    [
      summary("etl.extract.duration"),
      summary("etl.transform.duration"),
      summary("etl.load.duration")
    ]
  end
end

# retry.ex
defmodule ExEtlFramework.Retry do
  require Logger

  @default_max_attempts 3
  @default_initial_delay 1000
  @default_max_delay 5000

  def retry_with_backoff(fun, opts \\ []) do
    max_attempts = Keyword.get(opts, :max_attempts, @default_max_attempts)
    initial_delay = Keyword.get(opts, :initial_delay, @default_initial_delay)
    max_delay = Keyword.get(opts, :max_delay, @default_max_delay)

    do_retry(fun, 1, max_attempts, initial_delay, max_delay)
  end

  defp do_retry(fun, attempt, max_attempts, delay, max_delay) do
    case fun.() do
      {:ok, result} ->
        {:ok, result}

      {:error, reason} ->
        if attempt < max_attempts do
          Logger.warning("Attempt #{attempt} failed: #{inspect(reason)}. Retrying in #{delay}ms.")
          Process.sleep(delay)
          next_delay = min(delay * 2, max_delay)
          do_retry(fun, attempt + 1, max_attempts, next_delay, max_delay)
        else
          Logger.error("All #{max_attempts} attempts failed. Last error: #{inspect(reason)}")
          {:error, reason}
        end
    end
  end
end


# validator.ex
defmodule ExEtlFramework.Validator do
  def validate(data, schema) do
    Enum.reduce_while(schema, {:ok, data}, fn {field, validators}, {:ok, acc} ->
      case validate_field(data, field, validators) do
        :ok -> {:cont, {:ok, acc}}
        {:error, reason} -> {:halt, {:error, field, reason}}
        {:error, failed_field, reason} -> {:halt, {:error, failed_field, reason}}
      end
    end)
  end

  defp validate_field(data, field, validators) when is_list(validators) do
    value = Map.get(data, field)
    Enum.reduce_while(validators, :ok, fn validator, _acc ->
      case validator.(value) do
        :ok -> {:cont, :ok}
        {:error, reason} -> {:halt, {:error, reason}}
        other ->
          {:halt, other}
      end
    end)
  end

  def required(value) when is_nil(value), do: {:error, "Field is required"}
  def required(_value), do: :ok

  def type(expected_type) do
    fn value ->
      if is_nil(value) or is_type?(value, expected_type) do
        :ok
      else
        {:error, "Expected type #{inspect(expected_type)}, got #{inspect(value)}"}
      end
    end
  end

  defp is_type?(value, String), do: is_binary(value)
  defp is_type?(value, Integer), do: is_integer(value)
  defp is_type?(value, Float), do: is_float(value)
  defp is_type?(value, Number), do: is_number(value)
  defp is_type?(value, Atom), do: is_atom(value)
  defp is_type?(value, List), do: is_list(value)
  defp is_type?(value, Boolean), do: is_boolean(value)
  defp is_type?(value, Tuple), do: is_tuple(value)
  defp is_type?(value, Map), do: is_map(value)
  defp is_type?(value, Function), do: is_function(value)
  defp is_type?(value, PID), do: is_pid(value)
  defp is_type?(value, Port), do: is_port(value)
  defp is_type?(value, Reference), do: is_reference(value)
  defp is_type?(value, Struct), do: is_struct(value)
  defp is_type?(value, NaiveDateTime), do: is_struct(value, NaiveDateTime)
  defp is_type?(value, expected_type), do: is_struct(value, expected_type)
end



# pipeline.ex
defmodule ExEtlFramework.Pipeline do
  require Logger

  defmacro __using__(_opts) do
    quote do
      import ExEtlFramework.Pipeline
      @before_compile ExEtlFramework.Pipeline
      Module.register_attribute(__MODULE__, :steps, accumulate: true)

      def run(attributes, opts \\ []) do
        steps = __MODULE__.steps() |> Enum.reverse()
        error_strategy = Keyword.get(opts, :error_strategy, :collect_errors)

        Logger.debug("Starting pipeline run with attributes: #{inspect(attributes)}")
        Logger.debug("Steps to execute: #{inspect(steps)}")

        Enum.reduce_while(steps, {:ok, attributes, [], %{}}, fn step, {:ok, acc, errors, metrics} ->
          Logger.debug("Attempting to execute step: #{step}")
          retry_opts = Keyword.get(opts, :"#{step}_retry", [])

          {execution_time, result} = :timer.tc(fn ->
            try do
              ExEtlFramework.Retry.retry_with_backoff(
                fn ->
                  Logger.debug("Applying function for step: #{step}")
                  apply(__MODULE__, step, [acc])
                end,
                retry_opts
              )
            rescue
              e ->
                {:error, step, "Unexpected error: #{inspect(e)}"}
            end
          end)

          step_metrics = Map.put(metrics, step, execution_time / 1_000_000)
          Logger.info("Step #{step} completed in #{execution_time / 1_000_000} seconds")

          Logger.debug("Step #{step} result: #{inspect(result)}")

          case result do
            {:ok, step_result} ->
              if function_exported?(__MODULE__, :"validate_#{step}", 1) do
                Logger.debug("Validating step: #{step}")
                {validation_time, validation_result} = :timer.tc(fn ->
                  apply(__MODULE__, :"validate_#{step}", [step_result])
                end)

                validation_metrics = Map.put(step_metrics, :"#{step}_validation", validation_time / 1_000_000)
                Logger.info("Validation for step #{step} completed in #{validation_time / 1_000_000} seconds")

                case validation_result do
                  {:ok, validated} ->
                    Logger.debug("Validation successful for step: #{step}")
                    {:cont, {:ok, validated, errors, validation_metrics}}
                  {:error, invalid_records, valid_data} ->
                    handle_errors(error_strategy, step, invalid_records, valid_data, errors, validation_metrics)
                end
              else
                {:cont, {:ok, step_result, errors, step_metrics}}
              end
            {:error, reason} ->
              Logger.error("Step #{step} failed, reason: #{inspect(reason)}")
              handle_errors(error_strategy, step, reason, %{}, errors, step_metrics)
          end
        end)
      end

      defp handle_errors(:fail_fast, step, reason, _, errors, metrics) do
        Logger.error("Pipeline failed at step: #{step}, reason: #{inspect(reason)}, errors: #{inspect(errors)}")
        {:halt, {:error, step, reason, errors, metrics}}
      end

      defp handle_errors(:collect_errors, step, invalid_records, valid_data, errors, metrics) do
        new_errors = Enum.map(invalid_records, fn {record, reason} -> {step, record, reason} end)
        Logger.warning("Continuing pipeline with valid data. Errors: #{inspect(new_errors)}")
        {:cont, {:ok, valid_data, errors ++ new_errors, metrics}}
      end
    end
  end

  defmacro step(name, do: block) do
    quote do
      @steps unquote(name)
      def unquote(name)(var!(attributes)) do
        Logger.debug("Entering step #{unquote(name)} with attributes: #{inspect(var!(attributes))}")
        result = unquote(block)
        Logger.debug("Exiting step #{unquote(name)} with result: #{inspect(result)}")
        result
      end
    end
  end

  defmacro __before_compile__(env) do
    steps = Module.get_attribute(env.module, :steps)
    quote do
      def steps, do: unquote(Macro.escape(steps))
      Logger.debug("Defined steps: #{inspect(unquote(Macro.escape(steps)))}")
    end
  end
end

